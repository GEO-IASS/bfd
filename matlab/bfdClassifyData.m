function [params, model] = bfdClassifyData(dataset, dataType, partition, ...
                                         kernelType, invWidth, options)

% BFDCLASSIFYDATA Function used to classify a given dataset 

% BFD

% 
% Syntax:
% [params, model] = bfdClassifyData(dataset, dataType, partition, ...
%                                   kernelType, invWidth, options);
%
% Description:
% Classifies a given DATASET according to the parameters KERNELTYPE,
% INVWIDTH and OPTIONS. DATASET is a string with the name of the
% data to be used, while DATATYPE and PARTITION indicate whether it 
% is a Training or Test instance of the data and specify the
% Instance number of the data. 
% For more information regarding the way data is organized,
% please refer to the paper on AdaBoost by Gunnar Raetsch that is
% mentioned in the README file, reference [2].
% KERNELTYPE is a string that specifies the type of kernel to be used,
% eg {'rbf', 'bias', 'white'}, with each component of the kernel
% separated by 's. The following components are available in this
% implementation:
%
% 1. {'rbf'}   : kernel matrix with RBF basis functions  
% 2. {'lin'}   : kernel matrix with linear dot product
% 3. {'bias'}  : kernel matrix with a constant term
% 4. {'white'} : kernel matrix with only a diagonal term
% 5. {'rbfard'}: RBF kernel with ARD features  
% 6. {'linard'}: linear kernel with ARD features
%
% The combinations used for the experiments reported in the paper
% were: 
%      {'rbfard', 'linard', 'bias', white'} 
% and
%      {'rbf', 'bias', 'white'}
%
% The BFD algorithm is susceptible to fall into local minima so it
% is recommendable to try different initialisations. In the case of
% an RBF kernel, the INVERSE WIDTH parameter can be set to
% different values, see the BFD paper for more reference, [4].
% OPTIONS is the vector of optimisation options generated by
% applying the function FOPTIONS. Note that this vector will need
% to have appended 5 extra elements, so its dimensions will be
% [23,1]. It is recommended to take a look to the scripts
% CLASSSPECSKERNELTYPE. 
%
% Inputs
%   dataset   : a string specifying the name of the data to use
%   dataType  : any of the strings {'train', 'test'}
%   partition : a scalar indicating the instance of the data being
%               used
%   kernelType: a cell array of strings (see above)
%   invWidth  : scalar with initial value of Inverse width
%               parameter 
%   options   : vector of optimisation options. Size increased to
%               [23,1]    
%
% Outputs
%  params     : [t,1] vector of parameters in log-space, LNTHETA
%  model      : structure without changes
%
%
% Example:
% A typical run of this function would look like 
%
%         >>kernelType = {'rbfard', 'linard', 'bias', 'white'};
%         >>dataset = 'bumpy';
%         >>dataType = 'train';
%         >>partition = 1; invWidth = 1;
%         >>[params, model] = bfdClassifyData(dataset, dataType, ...
%                             partition, kernelType, invWidth, options);
%
%
% Other info: This function was used to run in Blaze, the cluster
%             of the PASCAL network
%
% See also: README file, classSpecsRBFBIASWHITE,
%           classSpecsRBFARDLINARDBIASWHITE  
%

% Structure with model specifications 
modSpecs.kernelType = strcat(kernelType{:});
modSpecs.gamma = struct('a', 0.5, 'b', 0.5);
modSpecs.dist = 2;

% Loading data set
fprintf('Working with data-set %s\n', dataset);
[X, y] = loadData(dataset, dataType, partition);

% Creating model
model = bfd(X, y, modSpecs);

% Setting initial inverseWidth
model.kern.lntheta(1) = log(invWidth); 
fprintf('Using initial invWidth = %2.4f\n', invWidth);

% Resetting prior and posterior kernels
model.kern.K = computeKernel(model.kern.lntheta, ...
                             model.kern.type, model.X);
% model.beta was updated when the BFD function was called
% Updating sigma
model = bfdUpdateSigma(model);

% Optimising the model
model = bfdOptimiseBFD(model, options);

% Creating a new model and testing it
params = model.kern.lntheta;
K = model.kern.K;
f = K*model.alpha;
model.bias = mean(f);

% Final bound
bound = bfdBound(model);
fprintf('Final bound is %2.4f\n', bound);


% If the model belongs to the toy datasets, then a 
% plot of the data will be saved
toyData = isequal(dataset, 'spiral') | isequal(dataset, 'bumpy') | ...
          isequal(dataset, 'overlap') | isequal(dataset, 'relevance');

% Saving results & info
try
  if ~toyData
    model = rmfield(model, 'X');
    model = rmfield(model, 'y');
  end
  Info(1) = {model};
  Info(2) = {bound};
  Info(3) = {dataset};
  Info(4) = {dataType};
  Info(5) = {partition};
  Info(6) = {kernelType};
  Info(7) = {invWidth};
  Info(8) = {options};
  Info(9) = {modSpecs};
catch
  Info(1:8) = [];	
end

% Saving...
bfdSaveData(kernelType, dataset, 'partialResults', params, Info, toyData);

